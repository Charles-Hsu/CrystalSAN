#  parse_engine_all.exp
#  
#
#  Created by Charles Hsu on 1/27/13.
#
#  usage:
#      expect parse_engine_all.exp <engine_last_part_of_ip> <database_filename>
#  for example:
#      $expect parse_engine_all.exp 227 server.db
#  will open the engine_227_all.xml file amd parse the information to database 'server.db'
#
#####################
#include public.exp
#####################
#source [file join [file dirname [info script]] xml.exp]

proc xml2list xml {
    regsub -all {>\s*<} [string trim $xml " \n\t<>"] "\} \{" xml
    set xml [string map {> "\} \{#text \{" < "\}\} \{"}  $xml]
    
    set res ""   ;# string to collect the result
    set stack {} ;# track open tags
    set rest {}
    foreach item "{$xml}" {
        switch -regexp -- $item {
            ^# {append res "{[lrange $item 0 end]} " ; #text item}
            ^/ {
                regexp {/(.+)} $item -> tagname ;# end tag
                set expected [lindex $stack end]
                if {$tagname!=$expected} {error "$item != $expected"}
                set stack [lrange $stack 0 end-1]
                append res "\}\} "
            }
            /$ { # singleton - start and end in one <> group
                regexp {([^ ]+)( (.+))?/$} $item -> tagname - rest
                set rest [lrange [string map {= " "} $rest] 0 end]
                append res "{$tagname [list $rest] {}} "
            }
            default {
                set tagname [lindex $item 0] ;# start tag
                set rest [lrange [string map {= " "} $item] 1 end]
                lappend stack $tagname
                append res "\{$tagname [list $rest] \{"
            }
        }
        if {[llength $rest]%2} {error "att's not paired: $rest"}
    }
    if [llength $stack] {error "unresolved: $stack"}
    string map {"\} \}" "\}\}"} [lindex $res 0]
}

proc list2xml list {
    switch -- [llength $list] {
        2 {lindex $list 1}
        3 {
            foreach {tag attributes children} $list break
            set res <$tag
            foreach {name value} $attributes {
                append res " $name=\"$value\""
            }
            if [llength $children] {
                append res >
                foreach child $children {
                    append res [list2xml $child]
                }
                append res </$tag>
            } else {append res />}
        }
        default {error "could not parse $list"}
    }
}
#-------------------------------------------- now testing:
set test {<foo a="b">bar and<grill x:c="d" e="f g"><baz x="y"/></grill><room/></foo>}

#set filename [lindex $argv 0]
#set fp [open $filename r]
#set file_data [read $fp]
#close $fp

proc tdomlist x {[[dom parse $x] documentElement root] asList} ;# reference
proc lequal {a b} {
    if {[llength $a] != [llength $b]} {return 0}
    if {[lindex $a 0] == $a} {return [string equal $a $b]}
    foreach i $a j $b {if {![lequal $i $j]} {return 0}}
    return 1
}
proc try x {
    puts [set a [tdomlist $x]]
    puts [set b [xml2list $x]]
    puts list:[lequal $a $b],string:[string equal $a $b]
}

proc keyvalue key {
    return [string trim [lindex [lindex [lindex $key 2] 0] 1]]
}

#set a [lindex [list a b "Hello World"] 2]
#puts $a

#set xmlfilename "engine_[lindex $argv 0]_all.xml"
set xmlfilename "[lindex $argv 0]"
puts "xml_filename=$xmlfilename"
set fp [open $xmlfilename r]
set file_data [read $fp]
close $fp

set db_filename [lindex $argv 1]
load /usr/lib/sqlite3/libtclsqlite3.dylib Sqlite3
sqlite3 db $db_filename



#db eval {CREATE TABLE IF NOT EXISTS t1(a TEXT, b INTEGER)}
#
#proc create_table_if_not_exist table_name {
#    set sql "create table if not exists $table_name (id integer)"
#    puts $sql
#    db eval $sql
#}
#
#create_table_if_not_exist "test_table"

set sql "create table if not exists engine_cli_vpd (serial text primary key, seconds integer, site_name text, engine_name text, product_type text, fw_version text, fw_data text, redboot text, uid text, pcb text, mac text, ip text, uptime text, alert text, time text, a1_wwpn, a2_wwpn, b1_wwpn, b2_wwpn)"
db eval $sql

#set res [xml2list $test
#puts $file_data
set site_data [lindex [xml2list $file_data] 2]
set site_name [lindex [lindex $site_data 0] 1]
set engines_data [lindex [lindex $site_data 0] 2]

puts "-------------"
puts "site_name=[lindex $site_name 1]"
#puts "type=[lindex [lindex [lindex $engines_data 0] 1] 1]"

#engine_name
set engine_name        [lindex [lindex [lindex [lindex $engines_data 0] 2] 0] 1] 
puts "engine_name=[lindex $engine_name 1]"

set engine_info [lindex [lindex [lindex [lindex $engines_data 0] 2] 0] 2]

#cli_vpd
set cli_vpd_section    [lindex $engine_info 0]
puts $cli_vpd_section
puts "------------- cli_vpd -------------"
set seconds         [lindex [lindex $cli_vpd_section 1] 1]
puts "seconds=$seconds"

set product_type_s [lindex [lindex $cli_vpd_section 2] 0]
set fw_version_s   [lindex [lindex $cli_vpd_section 2] 1]
set fw_date_s      [lindex [lindex $cli_vpd_section 2] 2]
set redboot_s      [lindex [lindex $cli_vpd_section 2] 3]
set uid_s          [lindex [lindex $cli_vpd_section 2] 4]
set serial_s       [lindex [lindex $cli_vpd_section 2] 5]
set pcb_s          [lindex [lindex $cli_vpd_section 2] 6]
set mac_s          [lindex [lindex $cli_vpd_section 2] 7]
set ip_s           [lindex [lindex $cli_vpd_section 2] 8]
set uptime_s       [lindex [lindex $cli_vpd_section 2] 9]
set alert_s        [lindex [lindex $cli_vpd_section 2] 10]
set time_s         [lindex [lindex $cli_vpd_section 2] 11]
set port_A1      [lindex [lindex $cli_vpd_section 2] 12]
set port_A2      [lindex [lindex $cli_vpd_section 2] 13]
set port_B1      [lindex [lindex $cli_vpd_section 2] 14]
set port_B2      [lindex [lindex $cli_vpd_section 2] 15]

#puts "product_type"
set product_type [string trim [lindex [lindex [lindex $product_type_s 2] 0] 1]]
puts "[lindex $product_type_s 0]=$product_type"

#puts $fw_version
set fw_version [string trim [lindex [lindex [lindex $fw_version_s 2] 0] 1]]
puts "[lindex $fw_version_s 0]=$fw_version"

#puts $fw_date
set fw_date [string trim [lindex [lindex [lindex $fw_date_s 2] 0] 1]]
puts "[lindex $fw_date_s 0]=$fw_date"

#puts $redboot
set redboot [string trim [lindex [lindex [lindex $redboot_s 2] 0] 1]]
puts "[lindex $redboot_s 0]=$redboot"

#puts $uid
set uid [string trim [lindex [lindex [lindex $uid_s 2] 0] 1]]
puts "[lindex $uid_s 0]=$uid"

#puts $serial
set serial [string trim [lindex [lindex [lindex $serial_s 2] 0] 1]]
puts "[lindex $serial_s 0]=$serial"

#puts $pcb
set pcb [string trim [lindex [lindex [lindex $pcb_s 2] 0] 1]]
puts "[lindex $pcb_s 0]=$pcb"

#puts $mac
set mac [string trim [lindex [lindex [lindex $mac_s 2] 0] 1]]
puts "[lindex $mac_s 0]=$mac"

#puts $ip
set ip [string trim [lindex [lindex [lindex $ip_s 2] 0] 1]]
puts "[lindex $ip_s 0]=$ip"

#puts $uptime
set uptime [keyvalue $uptime_s]
puts "[lindex $uptime_s 0]=$uptime"

#puts $alert
set alert [string trim [lindex [lindex [lindex $alert_s 2] 0] 1]]
puts "alert=$alert"

#puts $time
set time [keyvalue $time_s]
puts "[lindex $time_s 0]=$time"

#puts $port_A1
puts "[lindex [lindex $port_A1 1] 1]_[lindex [lindex [lindex $port_A1 2] 1] 0]=[lindex [lindex [lindex [lindex [lindex $port_A1 2] 1] 2] 0] 1]"
puts "[lindex [lindex $port_A1 1] 1]_[lindex [lindex [lindex $port_A1 2] 2] 0]=[lindex [lindex [lindex [lindex [lindex $port_A1 2] 2] 2] 0] 1]"
set a1_wwpn [lindex [lindex [lindex [lindex [lindex $port_A1 2] 2] 2] 0] 1]

#puts $port_A2
puts "[lindex [lindex $port_A2 1] 1]_[lindex [lindex [lindex $port_A2 2] 1] 0]=[lindex [lindex [lindex [lindex [lindex $port_A2 2] 1] 2] 0] 1]"
puts "[lindex [lindex $port_A2 1] 1]_[lindex [lindex [lindex $port_A2 2] 2] 0]=[lindex [lindex [lindex [lindex [lindex $port_A2 2] 2] 2] 0] 1]"
set a2_wwpn [lindex [lindex [lindex [lindex [lindex $port_A2 2] 2] 2] 0] 1]

#puts $port_B1
puts "[lindex [lindex $port_B1 1] 1]_[lindex [lindex [lindex $port_B1 2] 1] 0]=[lindex [lindex [lindex [lindex [lindex $port_B1 2] 1] 2] 0] 1]"
puts "[lindex [lindex $port_B1 1] 1]_[lindex [lindex [lindex $port_B1 2] 2] 0]=[lindex [lindex [lindex [lindex [lindex $port_B1 2] 2] 2] 0] 1]"
set b1_wwpn [lindex [lindex [lindex [lindex [lindex $port_B1 2] 2] 2] 0] 1]


#puts $port_B2
puts "[lindex [lindex $port_B2 1] 1]_[lindex [lindex [lindex $port_B2 2] 1] 0]=[lindex [lindex [lindex [lindex [lindex $port_B2 2] 1] 2] 0] 1]"
puts "[lindex [lindex $port_B2 1] 1]_[lindex [lindex [lindex $port_B2 2] 2] 0]=[lindex [lindex [lindex [lindex [lindex $port_B2 2] 2] 2] 0] 1]"
set b2_wwpn [lindex [lindex [lindex [lindex [lindex $port_B2 2] 2] 2] 0] 1]
puts "-------------"

#set seconds_in_table 0

#db eval {SELECT seconds FROM engine_cli_vpd WHERE serial='$serial'} {
#    puts "=======$seconds\\\\\\\\\\\\\////////////////"
#    set seconds_in_table $seconds
#}

#
#
# compare seconds in database and seconds in xml, 
# if seconds_in_table is equal to or bigger than seconds_in_xml, then exits
# otherwise, add the record to database
#
set sql "SELECT seconds FROM engine_cli_vpd WHERE serial='$serial'"
puts $sql
set seconds_in_table [db onecolumn $sql]
puts "seconds_in_table : $seconds_in_table"
puts "seconds_in_xml   : $seconds"
if {[expr $seconds > $seconds_in_table]} {
    set sql "insert into engine_cli_vpd values ('$serial', $seconds, '[lindex $site_name 1]', '[lindex $engine_name 1]', '$product_type', '$fw_version', '$fw_date', '$redboot', '$uid', '$pcb', '$mac', '$ip', '$uptime', '$alert', '$time', '$a1_wwpn', '$a2_wwpn', '$b1_wwpn', '$b2_wwpn')"
    db eval $sql
    puts "insert record"
} else {
    if {[expr $seconds == $seconds_in_table]} {
        puts "table($seconds_in_table) = xml($seconds). record exists, ignores"
    } else {
        puts "table($seconds_in_table) < xml($seconds). xml is older than database, ignores"
    }
    #exit
}

#cli_mirror
puts "------------- cli_mirror ----------"
set sql "create table if not exists engine_cli_mirror (serial text primary key, seconds integer, 
    mirror_0_id integer, mirror_0_sts text, mirror_0_map integer, mirror_0_capacity integer, mirror_0_member_0_id integer, mirror_0_member_0_sts text, mirror_0_member_1_id integer, mirror_0_member_1_sts text,
    mirror_1_id integer, mirror_1_sts text, mirror_1_map integer, mirror_1_capacity integer, mirror_1_member_0_id integer, mirror_1_member_0_sts text, mirror_1_member_1_id integer, mirror_1_member_1_sts text,
    mirror_2_id integer, mirror_2_sts text, mirror_2_map integer, mirror_2_capacity integer, mirror_2_member_0_id integer, mirror_2_member_0_sts text, mirror_2_member_1_id integer, mirror_2_member_1_sts text,
    mirror_3_id integer, mirror_3_sts text, mirror_3_map integer, mirror_3_capacity integer, mirror_3_member_0_id integer, mirror_3_member_0_sts text, mirror_3_member_1_id integer, mirror_3_member_1_sts text,
    mirror_4_id integer, mirror_4_sts text, mirror_4_map integer, mirror_4_capacity integer, mirror_4_member_0_id integer, mirror_4_member_0_sts text, mirror_4_member_1_id integer, mirror_4_member_1_sts text,
    mirror_5_id integer, mirror_5_sts text, mirror_5_map integer, mirror_5_capacity integer, mirror_5_member_0_id integer, mirror_5_member_0_sts text, mirror_5_member_1_id integer, mirror_5_member_1_sts text,
    mirror_ok integer, mirror_degraded integer, mirror_failed integer)"
db eval $sql

set cli_mirror_section [lindex $engine_info 1]

set seconds         [lindex [lindex $cli_mirror_section 1] 1]
puts "seconds=$seconds"

proc xml_is_older_than_database {args} {
    set seconds [lindex $args 0]
    set record_seconds [lindex $args 1] 
    puts "seconds $seconds, record_seconds $record_seconds"
    if {[string length $record_seconds] == 0} {
        puts "not exists"
        # not exists
        return "not_exists"
    }
    if {[expr $seconds > $record_seconds]} {
        puts "new record, update it"
        # new record
        return "new_record"
    }
    # older than current
    return "older"
}

proc keyvalue key {
    return [string trim [lindex [lindex [lindex $key 2] 0] 1]]
}

proc dress {seconds {size 1}} {
        upvar $text harry
        set harry "<h$size>$harry</h$size>"
        return [string length $harry]
        }
        
proc compare_seconds {xml_seconds db_seconds} {
    puts "xml_seconds $xml_seconds"
    puts "db_seconds $db_seconds"
    if {[string length $db_seconds] == 0} {
        return "not_exists"
    }
    if {[expr $xml_seconds > $db_seconds]} {
        return "old_record"
    }
    return "the_same"
}

#compare_seconds 123 456

        
set sql "select seconds from engine_cli_mirror where serial='$serial'"
puts $sql
set seconds_in_table [db eval $sql]
puts "seconds_in_table($seconds_in_table)"

puts "========"

#set val [xml_is_older_than_database {seconds seconds_in_table}]
#puts $val
#puts $new_or_old

puts "++++++++++++++++++++"
#compare_seconds $seconds $seconds_in_table
set compare_result [compare_seconds $seconds $seconds_in_table]
puts $compare_result
puts "++++++++++++++++++++"


#puts $cli_mirror_section
#puts [lindex [lindex $cli_mirror_section 2] 0]
#puts [lindex [lindex $cli_mirror_section 2] 1]
#puts [lindex [lindex $cli_mirror_section 2] 2]
#puts [lindex [lindex $cli_mirror_section 2] 3]
#puts [lindex [lindex $cli_mirror_section 2] 4]
#puts [lindex [lindex $cli_mirror_section 2] 5]
#puts "----"
set mirror_count [expr [llength [lindex $cli_mirror_section 2]]-3]
puts "mirror_count=$mirror_count"

set i 0
set sql "insert into engine_cli_mirror values ('$serial',$seconds"
for {} {$i < $mirror_count} {incr i 1} {
    append sql ","
    #puts [lindex [lindex $cli_mirror_section 2] $i]
    set mirror_data [lindex [lindex $cli_mirror_section 2] $i]
    set mirror_status [lindex [lindex $mirror_data 2] 1]
    set mirror_map [lindex [lindex $mirror_data 2] 2]
    set mirror_capacity [lindex [lindex $mirror_data 2] 3]
    puts "mirror_$i"
    puts "id_$i=[lindex [lindex $mirror_data 1] 1]"
    append sql "[lindex [lindex $mirror_data 1] 1]"
    puts "[lindex $mirror_status 0]_$i=[lindex [lindex [lindex $mirror_status 2] 0] 1]"
    append sql ",'[lindex [lindex [lindex $mirror_status 2] 0] 1]'"
    puts "[lindex $mirror_map 0]_$i=[lindex [lindex [lindex $mirror_map 2] 0] 1]"
    append sql ",[lindex [lindex [lindex $mirror_map 2] 0] 1]"
    puts "[lindex $mirror_capacity 0]_$i=[lindex [lindex [lindex $mirror_capacity 2] 0] 1]"
    append sql ",[lindex [lindex [lindex $mirror_capacity 2] 0] 1]"
    #puts [lindex [lindex $mirror_data 2] 4]
    
    set j 0
    puts "[lindex [lindex [lindex [lindex $mirror_data 2] 4] 1] 0]_$i-$j=[lindex [lindex [lindex [lindex $mirror_data 2] 4] 1] 1]"
    puts "[lindex [lindex [lindex [lindex $mirror_data 2] 4] 1] 0]_$i-$j-status=[lindex [lindex [lindex [lindex [lindex [lindex [lindex $mirror_data 2] 4] 2] 1] 2] 0] 1]"
    #puts [lindex [lindex $mirror_data 2] 5]
    append sql ",[lindex [lindex [lindex [lindex $mirror_data 2] 4] 1] 1],'[lindex [lindex [lindex [lindex [lindex [lindex [lindex $mirror_data 2] 4] 2] 1] 2] 0] 1]'"

    incr j 1 
    puts "[lindex [lindex [lindex [lindex $mirror_data 2] 5] 1] 0]_$i-$j=[lindex [lindex [lindex [lindex $mirror_data 2] 5] 1] 1]"
    puts "[lindex [lindex [lindex [lindex $mirror_data 2] 5] 1] 0]_$i-$j-status=[lindex [lindex [lindex [lindex [lindex [lindex [lindex $mirror_data 2] 5] 2] 1] 2] 0] 1]"
    append sql ",[lindex [lindex [lindex [lindex $mirror_data 2] 5] 1] 1],'[lindex [lindex [lindex [lindex [lindex [lindex [lindex $mirror_data 2] 5] 2] 1] 2] 0] 1]'"
}
for {} {$i < 6} {incr i 1} {
    append sql ",'','','','','','','',''"
}

set mirror_ok_data [lindex [lindex $cli_mirror_section 2] $mirror_count]
set mirror_degraded_data [lindex [lindex $cli_mirror_section 2] [expr $mirror_count+1]]
set mirror_failed_data [lindex [lindex $cli_mirror_section 2] [expr $mirror_count+2]]

puts "[lindex $mirror_ok_data 0]=[lindex [lindex [lindex $mirror_ok_data 2] 0] 1]"
append sql ",[lindex [lindex [lindex $mirror_ok_data 2] 0] 1]"

puts "[lindex $mirror_degraded_data 0]=[lindex [lindex [lindex $mirror_degraded_data 2] 0] 1]"
append sql ",[lindex [lindex [lindex $mirror_degraded_data 2] 0] 1]"

puts "[lindex $mirror_failed_data 0]=[lindex [lindex [lindex $mirror_failed_data 2] 0] 1]"
append sql ",[lindex [lindex [lindex $mirror_failed_data 2] 0] 1]"

append sql ")"

#compare_result --> not_exists, new_record, ignore

switch -- $compare_result \
  "not_exists" {
    puts "===>$compare_result"
    puts $sql
    db eval $sql
} "old_record" {
    puts "===>$compare_result"
} "the_same" {
    puts "===>$compare_result"
}



#puts $mirror_degraded_data
#puts $mirror_failed_data

proc printlist { inlist } {
        foreach item $inlist {
            # recurse - go into the sub list
            if { [llength $item] > 1 } {
                printlist $item 
            } else {
                puts $item
            }
        }
}
        
#printlist $cli_mirror_section

#puts "-------------"

set cli_conmgr_drive_status [lindex $engine_info 2]
#puts $cli_conmgr_drive_status

#puts "-------------"


#
#
# cli_conmgr_engine_status
#
#
puts ""
puts "<<<<<<< cli_conmgr_engine_status >>>>>>>"
puts ""

set sql "CREATE TABLE IF NOT EXISTS engine_cli_conmgr_engine_status (serial TEXT PRIMARY KEY, seconds INTEGER, cluster_id INTEGER, cluster_sts TEXT, 
    path_0_id INTEGER, path_0_port TEXT, path_0_wwpn TEXT, path_0_pstatus TEXT,
    path_1_id INTEGER, path_1_port TEXT, path_1_wwpn TEXT, path_1_pstatus TEXT)"
db eval $sql

set cli_conmgr_engine_status_block [lindex $engine_info 3]
#puts $cli_conmgr_engine_status_block
puts "serial=$serial"
puts "seconds=$seconds"

set sql "select seconds from engine_cli_conmgr_engine_status where serial='$serial'"
#puts $sql
set seconds_in_table [db eval $sql]
set compare_result [compare_seconds $seconds $seconds_in_table]
puts "compare result = $compare_result"

switch -- $compare_result \
  "not_exists" {

    set cluster_data [lindex [lindex [lindex $cli_conmgr_engine_status_block 2] 0] 2]
    #puts $cluster_data

    set cluster_id  [lindex [lindex [lindex [lindex $cluster_data 0] 2] 0] 1]
    puts "cluster_id=$cluster_id"

    set cluster_sts [lindex [lindex [lindex [lindex $cluster_data 1] 2] 0] 1]
    puts "cluster_sts=$cluster_sts"

    set path_0_data [lindex $cluster_data 2]
    # paths {id 1} {{port {} {{{#text} B1}}} {wwpn {} {{{#text} 2300-006022-09281e}}} {pstatus {} {{{#text} A}}}}

    set path_0_id   [lindex [lindex $path_0_data 1] 1]

    set path_0_port_data [lindex $path_0_data 2]
    # path_0_port_data => {port {} {{{#text} B1}}} {wwpn {} {{{#text} 2300-006022-09281e}}} {pstatus {} {{{#text} A}}}

    set path_0_port [lindex [lindex [lindex [lindex $path_0_port_data 0] 2] 0] 1]
    set path_0_port_wwpn [lindex [lindex [lindex [lindex $path_0_port_data 1] 2] 0] 1]
    set path_0_port_pstatus [lindex [lindex [lindex [lindex $path_0_port_data 2] 2] 0] 1]

    #puts $path_0_data
    puts "path_0_id=$path_0_id"
    puts "path_0_port=$path_0_port"
    puts "path_0_port_wwpn=$path_0_port_wwpn"
    puts "path_0_port_pstatus=$path_0_port_pstatus"

    set path_1_data [lindex $cluster_data 3]
    #puts $path_1_data
    #puts [lindex $cluster_data  2]
    # paths {id 1} {{port {} {{{#text} B1}}} {wwpn {} {{{#text} 2300-006022-09281e}}} {pstatus {} {{{#text} A}}}}

    set path_1_id   [lindex [lindex $path_1_data 1] 1]

    set path_1_port_data [lindex $path_1_data 2]
    # path_0_port_data => {port {} {{{#text} B1}}} {wwpn {} {{{#text} 2300-006022-09281e}}} {pstatus {} {{{#text} A}}}

    set path_1_port [lindex [lindex [lindex [lindex $path_1_port_data 0] 2] 0] 1]
    set path_1_port_wwpn [lindex [lindex [lindex [lindex $path_1_port_data 1] 2] 0] 1]
    set path_1_port_pstatus [lindex [lindex [lindex [lindex $path_1_port_data 2] 2] 0] 1]

    #puts $path_1_data
    puts "path_1_id=$path_1_id"
    puts "path_1_port=$path_1_port"
    puts "path_1_port_wwpn=$path_1_port_wwpn"
    puts "path_1_port_pstatus=$path_1_port_pstatus"

    set sql "INSERT INTO engine_cli_conmgr_engine_status VALUES ('$serial','$seconds','$cluster_id','$cluster_sts','$path_0_id','$path_0_port','$path_0_port_wwpn','$path_0_port_pstatus','$path_1_id','$path_1_port','$path_1_port_wwpn','$path_1_port_pstatus')"

    puts $sql
    db eval $sql
    
} "old_record" {
    puts "===>$compare_result"
} "the_same" {
    puts "===>$compare_result"
}


#puts "-------------"

set cli_conmgr_initiator_status [lindex $engine_info 4]
#puts $cli_conmgr_initiator_status

#puts "-------------"

set cli_rebuild [lindex $engine_info 5]
#puts $cli_rebuild

#puts "-------------"

set cli_rebuild_delay [lindex $engine_info 6]
#puts $cli_rebuild_delay

#puts "-------------"

set cli_rebuild_default [lindex $engine_info 7]
#puts $cli_rebuild_default

#puts "-------------"

set cli_rtc [lindex $engine_info 8]
#puts $cli_rtc

#puts "-------------"

set cli_history [lindex $engine_info 9]
#puts $cli_history

#puts "-------------"

set cli_failed [lindex $engine_info 10]
#puts $cli_failed

#puts "-------------"

set cli_detach [lindex $engine_info 11]
#puts $cli_detach

#puts "-------------"

set cli_timeout [lindex $engine_info 12]
#puts $cli_timeout

#puts "-------------"

set cli_port [lindex $engine_info 13]
#puts $cli_port

#puts "-------------"

set cli_detach_group [lindex $engine_info 14]
#puts $cli_detach_group

#puts "-------------"

set cli_dmeprop [lindex $engine_info 15]
#puts $cli_dmeprop

#puts "-------------"

set cli_map [lindex $engine_info 16]
#puts $cli_map


db close






